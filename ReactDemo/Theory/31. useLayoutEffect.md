## Syntax

```js
useLayoutEffect(() => {
  // DOM read/write
  return () => {
    // cleanup
  };
}, [dependencies]);
```

---

## 1ï¸âƒ£ Execution order (VERY IMPORTANT)

```txt
Render â†’ DOM updated â†’ useLayoutEffect â†’ Paint â†’ useEffect
```

* `useLayoutEffect` **blocks paint**
* `useEffect` runs **after paint**

---

## 2ï¸âƒ£ Why not always use `useLayoutEffect`?

âŒ Blocks UI rendering
âŒ Can cause performance issues

ðŸ‘‰ Default to `useEffect`
ðŸ‘‰ Use `useLayoutEffect` **only when necessary**

---

## 3ï¸âƒ£ Real use case: Measure DOM size

```js
import { useLayoutEffect, useRef, useState } from "react";

function Box() {
  const ref = useRef(null);
  const [width, setWidth] = useState(0);

  useLayoutEffect(() => {
    setWidth(ref.current.offsetWidth);
  }, []);

  return (
    <>
      <div ref={ref} className="box">Hello</div>
      <p>Width: {width}</p>
    </>
  );
}
```

âœ” No flicker
âœ” Accurate measurement

---

## 4ï¸âƒ£ Fixing layout flicker (key difference)

âŒ With `useEffect`

```js
useEffect(() => {
  ref.current.style.height = "200px";
}, []);
```

User may see flicker

âœ… With `useLayoutEffect`

```js
useLayoutEffect(() => {
  ref.current.style.height = "200px";
}, []);
```

Applied **before paint**

---

## 5ï¸âƒ£ Scroll position control

```js
useLayoutEffect(() => {
  window.scrollTo(0, 0);
}, []);
```

---

## useEffect vs useLayoutEffect (INTERVIEW TABLE)

| useEffect         | useLayoutEffect   |
| ----------------- | ----------------- |
| Async after paint | Sync before paint |
| Non-blocking      | Blocking          |
| Side effects      | DOM measurements  |
| Default choice    | Rare use          |

---

## Common mistakes âŒ

* Using it like `useEffect`
* Heavy logic inside it
* API calls inside it

---

## When to use `useLayoutEffect`

âœ” Measure DOM (width, height, position)
âœ” Prevent visual flicker
âœ” Sync DOM updates

âŒ Data fetching
âŒ Logging
âŒ Business logic

---

## Interview one-liner ðŸ’¡

> **`useLayoutEffect` runs synchronously after DOM updates but before paint, making it ideal for DOM measurements and preventing layout flicker.**
