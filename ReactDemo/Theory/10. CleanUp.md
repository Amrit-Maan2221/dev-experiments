# ðŸ§  Cleanup & Unmount

---

## 1ï¸âƒ£ First: What is Unmount?

You already know **mount**, so unmount is easy.

> **Unmount = when a component is removed from the screen**

### Examples

* You navigate away from a page
* You hide a component conditionally
* Parent stops rendering a child

```jsx
{showNotes && <Notes />}
```

When `showNotes` becomes `false`:
ðŸ‘‰ `<Notes />` **unmounts**

---

## 2ï¸âƒ£ Why Cleanup Is Needed

Some side effects **stay alive** even after UI disappears.

Examples:

* Timers keep running
* Event listeners keep listening
* Subscriptions stay open

This causes:
âŒ Memory leaks
âŒ Bugs
âŒ Unexpected behavior

So React says:

> â€œIf you create something in `useEffect`, clean it up when the component goes away.â€

---

## 3ï¸âƒ£ What is Cleanup?

> **Cleanup is a function that React runs BEFORE unmounting a component (or before re-running an effect)**

It lets you:

* Stop timers
* Remove listeners
* Cancel subscriptions

---

## 4ï¸âƒ£ `useEffect` Cleanup Syntax

```jsx
useEffect(() => {
  // setup code

  return () => {
    // cleanup code
  };
}, []);
```

That `return` function = **cleanup**

---

## 5ï¸âƒ£ When Does Cleanup Run? (CRITICAL)

Cleanup runs:
1ï¸âƒ£ **Before component unmounts**
2ï¸âƒ£ **Before effect runs again** (if dependencies change)

---

## 6ï¸âƒ£ Visual Timeline

### With empty dependency array `[]`

```
Mount â†’ useEffect runs
Unmount â†’ cleanup runs
```

---

### With dependencies `[value]`

```
Mount â†’ effect runs
value changes â†’ cleanup â†’ effect runs again
Unmount â†’ cleanup
```

---

## 7ï¸âƒ£ Real Example: Event Listener

### âŒ WRONG (Memory leak)

```jsx
useEffect(() => {
  window.addEventListener("resize", () => {
    console.log("resizing");
  });
}, []);
```

Problem:

* Listener is added
* NEVER removed
* Even after component unmounts

---

### âœ… CORRECT (With Cleanup)

```jsx
useEffect(() => {
  function handleResize() {
    console.log("resizing");
  }

  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);
```

---

## 8ï¸âƒ£ Real Example: Timer

### âŒ Wrong

```jsx
useEffect(() => {
  setInterval(() => {
    console.log("tick");
  }, 1000);
}, []);
```

Timer runs forever.

---

### âœ… Correct

```jsx
useEffect(() => {
  const intervalId = setInterval(() => {
    console.log("tick");
  }, 1000);

  return () => {
    clearInterval(intervalId);
  };
}, []);
```

---

## 9ï¸âƒ£ Local Storage + Cleanup (Clarification)

ðŸ‘‰ **localStorage does NOT need cleanup**

Why?

* Itâ€™s a one-time sync
* No ongoing process

So this is fine:

```jsx
useEffect(() => {
  localStorage.setItem("notes", JSON.stringify(notes));
}, [notes]);
```

Cleanup is only for:

* Ongoing side effects

---

## ðŸ”¥ Simple Rule (Memorize This)

> If your effect **starts something**, cleanup must **stop it**

---

## 10ï¸âƒ£ How React Thinks (Internals)

React does this:

1. Run effect
2. Remember cleanup function
3. Before unmount or re-run:

   * Call cleanup
4. Remove component safely

This keeps the app **stable & performant**.

---

## 11ï¸âƒ£ Common Beginner Mistakes

âŒ Forgetting cleanup
âŒ Using cleanup for state updates
âŒ Cleaning things that donâ€™t need cleaning
âŒ Creating new functions inside cleanup incorrectly

---

## ðŸ§  Mental Model (Final)

Think of `useEffect` like:

```js
onMount(() => {
  startSomething();

  onUnmount(() => {
    stopSomething();
  });
});
```
