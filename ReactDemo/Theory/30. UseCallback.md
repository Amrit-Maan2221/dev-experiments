## Syntax

```js
const memoizedFn = useCallback(() => {
  // logic
}, [dependencies]);
```

* Returns a **function**
* Function is recreated **only when dependencies change**

---

## 1ï¸âƒ£ Why `useCallback` exists (the problem)

```js
function Parent() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    console.log("clicked");
  };

  return <Child onClick={handleClick} />;
}
```

âŒ On every render, `handleClick` is a **new function**
âŒ Child re-renders even if nothing changed

---

## 2ï¸âƒ£ Fix with `useCallback`

```js
import { useCallback } from "react";

function Parent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log("clicked");
  }, []);

  return <Child onClick={handleClick} />;
}
```

âœ” Same function reference
âœ” Child wonâ€™t re-render unnecessarily

---

## 3ï¸âƒ£ Works best with `React.memo`

```js
const Child = React.memo(({ onClick }) => {
  console.log("Child rendered");
  return <button onClick={onClick}>Click</button>;
});
```

ğŸ‘‰ `useCallback` + `React.memo` = performance win

---

## 4ï¸âƒ£ Dependency example (VERY IMPORTANT)

```js
const handleAdd = useCallback(() => {
  setCount(count + 1);
}, [count]);
```

âš ï¸ If you forget `count` â†’ **stale value bug**

---

## 5ï¸âƒ£ useCallback vs normal function

| Normal function            | useCallback             |
| -------------------------- | ----------------------- |
| New function every render  | Same function reference |
| Can cause child re-renders | Prevents re-renders     |
| No memoization             | Memoized                |

---

## useCallback vs useMemo (INTERVIEW FAVORITE)

| useCallback       | useMemo                |
| ----------------- | ---------------------- |
| Memoizes function | Memoizes value         |
| Returns function  | Returns result         |
| Event handlers    | Expensive calculations |

Equivalent:

```js
useCallback(fn, deps)
```

â¬‡ï¸

```js
useMemo(() => fn, deps)
```

---

## When to use `useCallback`

âœ” Passing functions to memoized child
âœ” Event handlers
âœ” Prevent unnecessary re-renders

âŒ Local functions not passed as props
âŒ Overusing (adds memory overhead)

---

## Common mistakes âŒ

* Using `useCallback` everywhere
* Missing dependencies
* Using without `React.memo`

---