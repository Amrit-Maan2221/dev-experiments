# Nested Routes â€” Properly Explained

Nested routes are about **layout + hierarchy**, not just URLs.

---

## 1ï¸âƒ£ Why Nested Routes Exist

Look at these URLs:

```
/catalog
/catalog/123
/catalog/new
```

All of them:

* Belong to **Catalog**
* Should share:

  * Layout
  * Heading
  * Navigation
  * Maybe sidebar

Without nesting:

* You repeat UI
* Logic gets messy
* Components donâ€™t reflect structure

---

## 2ï¸âƒ£ Mental Model (Important)

Think in **parent â†’ child** relationships:

```
Catalog (parent)
 â”œâ”€â”€ CatalogList
 â”œâ”€â”€ CatalogItem (by id)
 â””â”€â”€ CreateCatalogItem
```

URL structure mirrors component structure.

---

## 3ï¸âƒ£ How Nested Routes Work Conceptually

Parent route:

```jsx
/catalog
```

Child routes:

```jsx
/catalog/:id
/catalog/new
```

React Router:

* Renders **parent**
* Inside it, renders **child**

---

## 4ï¸âƒ£ The Key Piece: `<Outlet />`

> `<Outlet />` is a placeholder where child routes render

Without `<Outlet />`:
âŒ Child routes will never show

---

## 5ï¸âƒ£ Refactor Catalog into a Layout Route




### Step 1: Create a Catalog Layout

```
src/pages/CatalogLayout.jsx
```

```jsx
import { Outlet } from "react-router-dom";

function CatalogLayout() {
  return (
    <div>
      <h1>Catalog</h1>
      <Outlet />
    </div>
  );
}

export default CatalogLayout;
```

---

## 6ï¸âƒ£ Step 2: Update Routes in `App.jsx`

```jsx
import { Routes, Route } from "react-router-dom";
import Home from "./pages/Home";
import Inventory from "./pages/Inventory";
import CatalogLayout from "./pages/CatalogLayout";
import Catalog from "./pages/Catalog";
import CatalogItem from "./pages/CatalogItem";

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/inventory" element={<Inventory />} />

      <Route path="/catalog" element={<CatalogLayout />}>
        <Route index element={<Catalog />} />
        <Route path=":id" element={<CatalogItem />} />
      </Route>
    </Routes>
  );
}

export default App;
```

---

## 7ï¸âƒ£ What `index` Means (Important)

```jsx
<Route index element={<Catalog />} />
```

This means:

> When URL is exactly `/catalog`, render `<Catalog />`

Without `index`:

* `/catalog` would render only layout
* No child content

---

## 8ï¸âƒ£ How This Renders (Visualization)

### URL: `/catalog`

```
CatalogLayout
 â”œâ”€ h1 Catalog
 â””â”€ Catalog
```

### URL: `/catalog/123`

```
CatalogLayout
 â”œâ”€ h1 Catalog
 â””â”€ CatalogItem (id=123)
```

---

## 9ï¸âƒ£ Why This Is Industry Standard

Nested routing:

* Reduces duplication
* Matches backend resource structure
* Scales well
* Keeps UI consistent

This is how real dashboards are built.

---

## 10ï¸âƒ£ Common Beginner Mistakes

âŒ Forgetting `<Outlet />`
âŒ Repeating `/catalog` in child paths
âŒ Not using `index`
âŒ Creating flat routes for hierarchical pages

You avoided all of them.

---

## App Setup Update
We will instead of a layout different for just Catalog, we will have a layout for our app.
So we will:

* ONE **App-level layout**
* Shared **Navbar**
* Shared **Footer**
* Page content swapped via routing

No Catalog-specific layout for now.

---

# App-Level Layout (Correct Mental Model)

## 1ï¸âƒ£ What We Want

Visually, every page should look like:

```
---------------------------------
Navbar (always visible)
---------------------------------
Page Content (changes by route)
---------------------------------
Footer (always visible)
---------------------------------
```

Only the **middle section** changes.

This is the **most common real-world pattern**.

---

## 2ï¸âƒ£ How React Router Supports This

React Router uses **layout routes**.

Key idea:

> A layout route renders shared UI and uses `<Outlet />` as a placeholder for pages.

---

## 3ï¸âƒ£ Folder Structure (Clean & Scalable)

Letâ€™s organize properly:

```
src/
 â”œâ”€ components/
 â”‚   â”œâ”€ Navbar.jsx
 â”‚   â””â”€ Footer.jsx
 â”œâ”€ layouts/
 â”‚   â””â”€ AppLayout.jsx
 â”œâ”€ pages/
 â”‚   â”œâ”€ Home.jsx
 â”‚   â”œâ”€ Catalog.jsx
 â”‚   â””â”€ Inventory.jsx
 â”œâ”€ App.jsx
 â””â”€ main.jsx
```

Why this matters:

* `components` â†’ reusable UI pieces
* `layouts` â†’ structural wrappers
* `pages` â†’ route-level screens

---

## 4ï¸âƒ£ Create Navbar & Footer

### `Navbar.jsx`

```jsx
import { Link } from "react-router-dom";

function Navbar() {
  return (
    <nav>
      <Link to="/">Home</Link> |{" "}
      <Link to="/catalog">Catalog</Link> |{" "}
      <Link to="/inventory">Inventory</Link>
    </nav>
  );
}

export default Navbar;
```

ğŸ“Œ We use `<Link>` (not `<a>`) â€” SPA navigation, no reload.

---

### `Footer.jsx`

```jsx
function Footer() {
  return (
    <footer>
      <p>Â© Play Frontend</p>
    </footer>
  );
}

export default Footer;
```

---

## 5ï¸âƒ£ Create the App Layout

### `layouts/AppLayout.jsx`

```jsx
import { Outlet } from "react-router-dom";
import Navbar from "../components/Navbar";
import Footer from "../components/Footer";

function AppLayout() {
  return (
    <>
      <Navbar />
      <main>
        <Outlet />
      </main>
      <Footer />
    </>
  );
}

export default AppLayout;
```

ğŸ”‘ **This is the key file**.

`<Outlet />` = â€œrender the current page hereâ€.

---

## 6ï¸âƒ£ Wire Layout into Routing (`App.jsx`)

Now routing becomes **clean and expressive**.

```jsx
import { Routes, Route } from "react-router-dom";
import AppLayout from "./layouts/AppLayout";
import Home from "./pages/Home";
import Catalog from "./pages/Catalog";
import Inventory from "./pages/Inventory";
import CatalogItem from "./pages/CatalogItem";

function App() {
  return (
    <Routes>
      <Route element={<AppLayout />}>
        <Route path="/" element={<Home />} />
        <Route path="/catalog" element={<Catalog />} />
        <Route path="/catalog/:id" element={<CatalogItem />} />
        <Route path="/inventory" element={<Inventory />} />
      </Route>
    </Routes>
  );
}

export default App;
```

---

## 7ï¸âƒ£ How This Actually Renders (Important)

### URL: `/`

```
AppLayout
 â”œâ”€ Navbar
 â”œâ”€ Home
 â””â”€ Footer
```

### URL: `/catalog`

```
AppLayout
 â”œâ”€ Navbar
 â”œâ”€ Catalog
 â””â”€ Footer
```

Navbar & Footer **never unmount**
Only page component swaps.

This is ideal for:

* Performance
* UX
* State preservation

---

## 8ï¸âƒ£ Why This Is the Right Design

âœ… Shared UI defined once
âœ… No duplication
âœ… Pages stay focused on data
âœ… Easy to add more routes
âœ… Matches real production apps

You chose the **correct abstraction level**.

---

## 9ï¸âƒ£ Common Mistakes You Avoided

âŒ Layout inside every page
âŒ Navbar inside App.jsx without routing awareness
âŒ Re-rendering navbar on every route change unnecessarily
âŒ Tight coupling pages with layout

---

## ğŸ”‘ One-Line Summary

> **An app-level layout uses `<Outlet />` to render different pages while keeping shared UI like Navbar and Footer mounted.**