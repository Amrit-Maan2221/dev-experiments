# Protected Routes (Concept â†’ Pattern â†’ Implementation)

## 1ï¸âƒ£ What Is a Protected Route?

A **protected route** is a route that:

* **Requires some condition** to be true
* Otherwise â†’ redirect user

Example:

```
/inventory   âŒ (not logged in)
/inventory   âœ… (logged in)
```

Condition examples:

* Logged in
* Has role (admin)
* Has subscription
* Feature enabled

---

## 2ï¸âƒ£ Core Idea (Very Important)

React Router **does not protect routes by default**.

Protection is implemented using:

* A **wrapper component**
* `<Navigate />`
* `<Outlet />`

> Routes are **just components** â€” control rendering like any component.

---

## 3ï¸âƒ£ Fake Auth (For Learning)

Weâ€™ll start simple.

Create a fake auth flag:

```js
const isAuthenticated = false;
```

Later this becomes:

* Context
* JWT
* API check
* Redux
* etc.

---

## 4ï¸âƒ£ The ProtectedRoute Component (Key Pattern)

### `components/ProtectedRoute.jsx`

```jsx
import { Navigate, Outlet } from "react-router-dom";

function ProtectedRoute({ isAuthenticated }) {
  if (!isAuthenticated) {
    return <Navigate to="/" replace />;
  }

  return <Outlet />;
}

export default ProtectedRoute;
```

### Whatâ€™s happening?

* If âŒ authenticated â†’ redirect
* If âœ… authenticated â†’ render child routes
* `<Outlet />` renders the protected page

---

## 5ï¸âƒ£ Apply Protection in Routing (App.jsx)

We protect **Inventory** only.

```jsx
import ProtectedRoute from "./components/ProtectedRoute";

const isAuthenticated = false; // fake auth for now

<Routes>
  <Route element={<AppLayout />}>
    <Route path="/" element={<Home />} />
    <Route path="/catalog" element={<Catalog />} />
    <Route path="/catalog/:id" element={<CatalogDetails />} />

    <Route element={<ProtectedRoute isAuthenticated={isAuthenticated} />}>
      <Route path="/inventory" element={<Inventory />} />
    </Route>
  </Route>
</Routes>
```

---

## 6ï¸âƒ£ How Routing Actually Resolves This

### When user visits `/inventory`:

```
AppLayout
 â””â”€ ProtectedRoute
     â”œâ”€ checks auth
     â”œâ”€ âŒ redirect â†’ "/"
     â””â”€ OR
     â””â”€ Outlet â†’ Inventory
```

Inventory **never renders** if unauthorized.

---

## 7ï¸âƒ£ Why This Pattern Is Powerful

âœ… No duplication
âœ… Clean route definitions
âœ… Supports multiple protected pages
âœ… Easily extendable to roles

---

## 8ï¸âƒ£ Protect Multiple Routes

```jsx
<Route element={<ProtectedRoute isAuthenticated={isAuthenticated} />}>
  <Route path="/inventory" element={<Inventory />} />
  <Route path="/admin" element={<Admin />} />
</Route>
```

One guard â†’ many routes.

---

## 9ï¸âƒ£ Role-Based Protection (Preview)

Later youâ€™ll do:

```jsx
function ProtectedRoute({ user, allowedRoles }) {
  if (!user || !allowedRoles.includes(user.role)) {
    return <Navigate to="/" />;
  }
  return <Outlet />;
}
```

This is **enterprise-grade routing**.

---

## 10ï¸âƒ£ Common Mistakes (Avoid These)

âŒ Protecting inside page component
âŒ Using `useEffect` for redirect
âŒ Redirect loops
âŒ Auth logic scattered everywhere

Protected route = **single responsibility**

---

## ğŸ”‘ One-Line Rule

> **Protect routes at the routing level, not inside pages.**

---

## ğŸ§  Mental Model

ProtectedRoute is **just a conditional wrapper**.

```jsx
isAuthenticated ? <Page /> : <Redirect />
```

But done at **routing level**.