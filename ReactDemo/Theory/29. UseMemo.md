### `useMemo` in React

`useMemo` is a React Hook used to **memoize (cache) a computed value** so it is **not recalculated on every render**.

ðŸ‘‰ It helps with **performance optimization**.

---

## Syntax

```js
const memoizedValue = useMemo(() => {
  return expensiveCalculation();
}, [dependencies]);
```

* Function runs **only when dependencies change**
* Cached value is reused otherwise

---

## 1ï¸âƒ£ Basic Example

```js
import { useMemo, useState } from "react";

function Example() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  const doubleCount = useMemo(() => {
    console.log("Calculating...");
    return count * 2;
  }, [count]);

  return (
    <>
      <h2>{doubleCount}</h2>
      <button onClick={() => setCount(count + 1)}>+</button>
      <input onChange={(e) => setText(e.target.value)} />
    </>
  );
}
```

ðŸ”¹ Typing in input âŒ does NOT recalculate
ðŸ”¹ Clicking button âœ… recalculates

---

## 2ï¸âƒ£ Expensive calculation example

```js
const expensiveValue = useMemo(() => {
  let sum = 0;
  for (let i = 0; i < 1e7; i++) {
    sum += i;
  }
  return sum;
}, []);
```

Runs **only once** on mount.

---

## 3ï¸âƒ£ Derived data (filtering / sorting)

```js
const filteredUsers = useMemo(() => {
  return users.filter(u => u.active);
}, [users]);
```

âœ” Prevents unnecessary filtering on every render

---

## 4ï¸âƒ£ useMemo vs normal variable

âŒ Without `useMemo`

```js
const total = items.reduce((a, b) => a + b.price, 0);
```

Runs on **every render**

âœ… With `useMemo`

```js
const total = useMemo(() => {
  return items.reduce((a, b) => a + b.price, 0);
}, [items]);
```

---

## â— useMemo is NOT for side effects

âŒ Wrong

```js
useMemo(() => {
  fetchData();
}, []);
```

âœ… Correct

```js
useEffect(() => {
  fetchData();
}, []);
```

---

## useMemo vs useCallback (VERY IMPORTANT)

| useMemo                | useCallback                   |
| ---------------------- | ----------------------------- |
| Memoizes value         | Memoizes function             |
| Returns result         | Returns function              |
| `useMemo(() => value)` | `useCallback(() => fn, deps)` |

Example:

```js
const memoizedFn = useCallback(() => {
  doSomething();
}, []);
```

Same as:

```js
const memoizedFn = useMemo(() => {
  return () => doSomething();
}, []);
```

---

## When to use `useMemo`

âœ” Expensive calculations
âœ” Derived data (filter, sort, map)
âœ” Prevent unnecessary recalculation

âŒ Small/cheap calculations
âŒ Premature optimization

---

## Interview one-liner ðŸ’¡

> **`useMemo` caches the result of a function and recalculates it only when dependencies change.**
