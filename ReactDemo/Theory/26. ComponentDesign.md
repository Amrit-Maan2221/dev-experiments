# 1ï¸âƒ£ Container vs Presentational Components

### Why?

To separate:

* **Logic (brain)**
* **UI (face)**

### Simple rule

> If a component knows **how data changes â†’ container**
> If a component knows **how data looks â†’ presentational**

---

### Example

**Container**

```jsx
function NotesContainer() {
  const [notes, setNotes] = useState([]);

  function addNote(text) {
    setNotes([...notes, { id: Date.now(), text }]);
  }

  return <NotesUI notes={notes} onAdd={addNote} />;
}
```

**Presentational**

```jsx
function NotesUI({ notes, onAdd }) {
  return (
    <>
      {notes.map(n => <p key={n.id}>{n.text}</p>)}
      <button onClick={() => onAdd("New Note")}>Add</button>
    </>
  );
}
```

âœ” Clean
âœ” Testable
âœ” Readable

---

# 2ï¸âƒ£ Reusable Components (Very Important)

## What makes a component reusable?

A reusable component:

* Has **no business logic**
* Is driven by **props**
* Is **generic**, not app-specific

---

## âŒ Bad (Not Reusable)

```jsx
function Button() {
  return <button onClick={saveNote}>Save</button>;
}
```

ğŸš« Tied to one feature

---

## âœ… Good (Reusable)

```jsx
function Button({ children, onClick, type = "button" }) {
  return (
    <button onClick={onClick} type={type}>
      {children}
    </button>
  );
}
```

âœ” Works everywhere
âœ” Accepts behavior via props

---

## Reusability Rule of Thumb

> **If you can use it in another app without changing code â†’ reusable**

---

## Real Examples of Reusable Components

* Button
* Input
* Modal
* Card
* Loader
* Navbar
* Table

---

# 3ï¸âƒ£ Props Drilling Problem (IMPORTANT PAIN POINT)

## What is Props Drilling?

> Passing props through **multiple levels** just to reach a deep child.

---

### Example

```jsx
function App() {
  const user = { name: "Amrit" };
  return <Dashboard user={user} />;
}

function Dashboard({ user }) {
  return <Sidebar user={user} />;
}

function Sidebar({ user }) {
  return <Profile user={user} />;
}

function Profile({ user }) {
  return <p>{user.name}</p>;
}
```

ğŸš¨ Problem:

* Dashboard & Sidebar **donâ€™t use `user`**
* They only pass it down
* Hard to maintain
* Easy to break

---

## Why Props Drilling is Bad

âŒ Tight coupling
âŒ Poor readability
âŒ Hard refactoring
âŒ Prop explosion

---

# 4ï¸âƒ£ How These 3 Topics Are Connected

```
Container Components
   â†“
Reusable Presentational Components
   â†“
Props passed down
   â†“
Too many levels = Props Drilling
```

ğŸ‘‰ **Good architecture reduces props drilling**

---

# 5ï¸âƒ£ Solutions to Props Drilling (Preview)

### 1ï¸âƒ£ Component Composition

```jsx
<Layout>
  <Profile />
</Layout>
```

### 2ï¸âƒ£ Context API âœ… (React built-in)

```jsx
<UserContext.Provider value={user}>
```

### 3ï¸âƒ£ State Management (Redux, Zustand)

(for large apps)

---

# 6ï¸âƒ£ How Seniors Think About This

âŒ Not:

> â€œAvoid props drilling at all costsâ€

âœ… Instead:

> â€œProps drilling is fine for 1â€“2 levels. Use Context only when data is truly global.â€

---

# 7ï¸âƒ£ Interview-Ready Answers

### â“ What is props drilling?

> Passing props through components that donâ€™t need them, only to reach deeper children.

---

### â“ How to avoid it?

> Component composition, Context API, or state management libraries.

---

### â“ Difference between container & reusable components?

> Containers manage logic and state, reusable components focus on UI and are driven by props.

---

# 8ï¸âƒ£ In Your Notes App (Practical Mapping)

| Component | Type           |
| --------- | -------------- |
| NotesPage | Container      |
| NotesList | Presentational |
| NoteItem  | Presentational |
| Button    | Reusable       |
| Input     | Reusable       |

---
