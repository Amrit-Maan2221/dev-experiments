1Ô∏è‚É£ What Problem Context API Solves

Context solves **prop drilling**.

‚ùå Without Context:

```jsx
<App user={user}>
  <Layout user={user}>
    <Navbar user={user} />
  </Layout>
</App>
```

‚úî With Context:

```jsx
<UserProvider>
  <Navbar />
</UserProvider>
```

---

## 2Ô∏è‚É£ `createContext`

Creates a **context object**.

```jsx
const UserContext = React.createContext(null);
```

What React creates internally:

```js
{
  Provider,
  Consumer,
  _currentValue
}
```

üìå Default value is used **only if no Provider exists**.

---

## 3Ô∏è‚É£ `Provider` (How Data Flows)

```jsx
function UserProvider({ children }) {
  const [user, setUser] = React.useState(null);

  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}
```

‚úî Every component inside can access `user`.

---

## 4Ô∏è‚É£ `useContext`

Consumes the nearest Provider value.

```jsx
function Navbar() {
  const { user } = React.useContext(UserContext);
  return <div>{user?.name}</div>;
}
```

Internally:

* React subscribes `Navbar` to `UserContext`
* On value change ‚Üí `Navbar` re-renders

---

## 5Ô∏è‚É£ Important Rule ‚ö†Ô∏è

> **Any change to `value` causes ALL consumers to re-render**

Even if:

```js
{ user, setUser }
```

Only `setUser` changed reference.

---

## 6Ô∏è‚É£ Avoiding Re-renders (VERY IMPORTANT)

### ‚ùå Common Mistake

```jsx
<UserContext.Provider value={{ user, setUser }}>
```

New object created every render ‚Üí triggers re-renders.

---

### ‚úÖ Solution 1: `useMemo`

```jsx
const value = React.useMemo(() => ({
  user,
  setUser
}), [user]);

<UserContext.Provider value={value}>
```

‚úî Stable reference
‚úî Fewer re-renders

---

### ‚úÖ Solution 2: Split Contexts (Best Practice)

‚ùå One big context:

```js
{ user, theme, language }
```

‚úî Split:

```js
UserContext
ThemeContext
LanguageContext
```

Now updates are isolated.

---

### ‚úÖ Solution 3: Context Selector Pattern

Only consume what you need.

```jsx
const user = useContext(UserContext).user;
```

Or use libraries:

* `use-context-selector`
* Zustand (better for performance)

---

### ‚úÖ Solution 4: Move State Down

If only one subtree needs state ‚Üí don‚Äôt globalize it.

---

## 7Ô∏è‚É£ When Context Is GOOD vs BAD

### ‚úÖ Good for:

* Auth user
* Theme
* Locale
* Feature flags

### ‚ùå Bad for:

* Frequently changing data
* High-frequency updates (scroll, typing)
* Large lists

---

## 8Ô∏è‚É£ Context vs Redux (Quick Compare)

| Feature             | Context      | Redux     |
| ------------------- | ------------ | --------- |
| Built-in            | Yes          | No        |
| Structure           | No           | Yes       |
| Debugging           | Weak         | Excellent |
| Performance control | Manual       | Built-in  |
| Scale               | Small‚ÄìMedium | Large     |

---

## 9Ô∏è‚É£ Interview One-Liners ‚≠ê

**What is Context?**

> A way to share data without prop drilling.

**Why re-renders happen?**

> Because context compares values by reference.

**How to optimize Context?**

> Memoize values, split contexts, avoid frequent updates.

---