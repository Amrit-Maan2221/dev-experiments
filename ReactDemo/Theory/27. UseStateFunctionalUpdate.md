# `useState` â€” Functional Updates

## 1ï¸âƒ£ Normal `useState` (What you already know)

```jsx
const [count, setCount] = useState(0);

setCount(count + 1);
```

### Whatâ€™s happening?

* `count` is the **current renderâ€™s value**
* `setCount` schedules a **re-render**
* React does **NOT update immediately**

---

## 2ï¸âƒ£ The Problem (Very Important)

### âŒ This looks correct but is WRONG in some cases

```jsx
setCount(count + 1);
setCount(count + 1);
```

### What do you expect?

`count + 2`

### What actually happens?

ğŸ‘‰ `count + 1`

### WHY?

Because:

* React **batches updates**
* Both updates use the **same stale `count` value**

---

# 3ï¸âƒ£ Functional Update â€” The Solution

### âœ… Correct Way

```jsx
setCount(prevCount => prevCount + 1);
setCount(prevCount => prevCount + 1);
```

### What is `prevCount`?

> The **latest state value**, guaranteed by React

React applies updates **one by one** using the returned value.

---

## 4ï¸âƒ£ Key Rule (MEMORIZE THIS)

> **If next state depends on previous state â†’ use functional update**

---

# 5ï¸âƒ£ Real Example (Notes App)

### âŒ Buggy Code

```jsx
function addTwoNotes() {
  setNotes([...notes, note1]);
  setNotes([...notes, note2]);
}
```

Problem:

* Both updates use **same `notes`**
* First update gets overwritten

---

### âœ… Correct Code

```jsx
function addTwoNotes() {
  setNotes(prev => [...prev, note1]);
  setNotes(prev => [...prev, note2]);
}
```

âœ” Safe
âœ” Predictable

---

# 6ï¸âƒ£ When You MUST Use Functional Updates

### Use it when:

âœ” Multiple state updates in one event
âœ” Async logic (timeouts, promises)
âœ” State depends on previous value

---

### Example: Timer âŒ

```jsx
setTimeout(() => {
  setCount(count + 1); // stale
}, 1000);
```

### âœ… Correct

```jsx
setTimeout(() => {
  setCount(prev => prev + 1);
}, 1000);
```

---

# 7ï¸âƒ£ Functional Update with Objects

```jsx
setUser(prev => ({
  ...prev,
  name: "Amrit"
}));
```

âœ” Prevents losing other fields
âœ” Works with concurrent updates

---

# 8ï¸âƒ£ Interview-Level Explanation

### â“ Why does React recommend functional updates?

> Because state updates are asynchronous and batched. Functional updates guarantee access to the latest state value.

---

### â“ When should you NOT use it?

* When next state **does not depend** on previous state

```jsx
setIsOpen(true); // normal is fine
```

---

# 9ï¸âƒ£ Mental Model (Very Important)

```
Normal setState â†’ uses value from render
Functional update â†’ uses value from React
```

---

# ğŸ”¥ Quick Summary

| Scenario                  | Which to use |
| ------------------------- | ------------ |
| Depends on previous state | âœ… Functional |
| Async code                | âœ… Functional |
| Multiple updates          | âœ… Functional |
| Direct assignment         | Normal       |