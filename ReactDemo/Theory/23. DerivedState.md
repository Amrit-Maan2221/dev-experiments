# Derived State in React

## 1Ô∏è‚É£ What Is Derived State?

> **Derived state** is state that can be **calculated from existing props or state**, instead of being stored independently.

In simple words:

> If you can compute it, **don‚Äôt store it**.

---

## 2Ô∏è‚É£ Simple Example (Bad Pattern)

```jsx
function Cart({ items }) {
  const [total, setTotal] = useState(0);

  useEffect(() => {
    setTotal(items.reduce((sum, i) => sum + i.price, 0));
  }, [items]);

  return <div>Total: {total}</div>;
}
```

### Why This Is Bad

* `total` is **derived from `items`**
* Duplicate source of truth
* Risk of stale or inconsistent data
* Extra state + effect

---

## 3Ô∏è‚É£ Correct Way (Derived, Not Stored)

```jsx
function Cart({ items }) {
  const total = items.reduce((sum, i) => sum + i.price, 0);

  return <div>Total: {total}</div>;
}
```

‚úî Simple
‚úî Always correct
‚úî No extra state

---

## 4Ô∏è‚É£ Core Rule (Memorize This)

> **State should represent the minimum data needed to describe your UI.**

Everything else ‚Üí derive.

---

# 5Ô∏è‚É£ Common Real-World Derived State Examples

### Example 1: Filtered List

‚ùå Wrong

```jsx
const [filteredItems, setFilteredItems] = useState([]);
```

‚úÖ Correct

```jsx
const filteredItems = items.filter(i => i.price > 10);
```

---

### Example 2: Computed Flags

‚ùå Wrong

```jsx
const [isEmpty, setIsEmpty] = useState(false);
```

‚úÖ Correct

```jsx
const isEmpty = items.length === 0;
```

---

### Example 3: UI Labels

‚ùå Wrong

```jsx
const [buttonText, setButtonText] = useState("Save");
```

‚úÖ Correct

```jsx
const buttonText = isLoading ? "Saving..." : "Save";
```

---

# 6Ô∏è‚É£ Derived State from Props (Classic Trap)

```jsx
function Input({ initialValue }) {
  const [value, setValue] = useState(initialValue); ‚ùå
}
```

### Problem:

* If `initialValue` changes ‚Üí state does NOT update

---

### Correct Patterns

#### Option 1: Fully Controlled

```jsx
function Input({ value, onChange }) {
  return <input value={value} onChange={onChange} />;
}
```

#### Option 2: Sync Explicitly (Rare)

```jsx
useEffect(() => {
  setValue(initialValue);
}, [initialValue]);
```

‚ö†Ô∏è Use sparingly.

---

# 7Ô∏è‚É£ When Derived State IS Okay

Derived state is acceptable **only when**:

* Expensive calculation
* Needs memoization
* Depends on async timing
* User edits derived value

Example:

```jsx
const computedValue = useMemo(() => heavyCalc(data), [data]);
```

This is still **derived**, but optimized.

---

# 8Ô∏è‚É£ Derived State in Your Project (Examples)

### Catalog

* `isLoading`
* `hasItems`
* `totalItems`
* `formattedPrice`

‚úî Derived
‚ùå Don‚Äôt store

---

### Inventory

* `isOutOfStock`
* `totalQuantity`
* `hasInventory`

‚úî Derived
‚ùå Don‚Äôt store

---

# 9Ô∏è‚É£ Common Interview Question

**Q:** Why is derived state considered an anti-pattern?

**A:**
Because it duplicates data that can be computed, leading to inconsistencies and unnecessary complexity.

---

# üîë Golden Rule (Write This Down)

> **If state can be calculated from props or other state, don‚Äôt put it in state.**

---
