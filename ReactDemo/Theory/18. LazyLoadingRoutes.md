# Lazy Loading Routes (React Router)

## 1Ô∏è‚É£ What Is Lazy Loading?

Lazy loading means:

> **Load code only when it is needed**

Instead of loading **all pages at startup**, we load:

* Home ‚Üí when user visits `/`
* Catalog ‚Üí when user visits `/catalog`
* Inventory ‚Üí when user visits `/inventory`

---

## 2Ô∏è‚É£ Why Lazy Loading Matters (Real World)

Without lazy loading:

* Large JS bundle
* Slow first load
* Poor Lighthouse score

With lazy loading:

* Faster initial render
* Smaller JS bundle
* Better UX
* Scales well with microservices frontend

This matters **a lot** for your Play frontend.

---

## 3Ô∏è‚É£ What Can Be Lazy Loaded?

In React:

* Components
* Pages
* Routes (most common)
* Heavy charts / editors

We usually lazy load:
üëâ **Page-level components**

---

## 4Ô∏è‚É£ React‚Äôs Built-in Lazy Loading

React gives us:

```js
React.lazy()
```

and

```jsx
<Suspense />
```

They always go **together**.

---

## 5Ô∏è‚É£ Basic Syntax (Minimal Example)

```jsx
import { lazy, Suspense } from "react";

const Home = lazy(() => import("./pages/Home"));

<Suspense fallback={<div>Loading...</div>}>
  <Home />
</Suspense>
```

Key idea:

* `lazy()` ‚Üí async import
* `Suspense` ‚Üí shows fallback while loading

---

## 6Ô∏è‚É£ Apply Lazy Loading to Routes (Correct Pattern)

### Step 1: Lazy import pages

```jsx
import { lazy, Suspense } from "react";

const Home = lazy(() => import("./pages/Home"));
const Catalog = lazy(() => import("./pages/Catalog"));
const CatalogDetails = lazy(() => import("./pages/CatalogDetails"));
const Inventory = lazy(() => import("./pages/Inventory"));
```

---

### Step 2: Wrap Routes with `Suspense`

```jsx
<Suspense fallback={<div>Loading page...</div>}>
  <Routes>
    <Route element={<AppLayout />}>
      <Route path="/" element={<Home />} />
      <Route path="/catalog" element={<Catalog />} />
      <Route path="/catalog/:id" element={<CatalogDetails />} />

      <Route element={<ProtectedRoute isAuthenticated={isAuthenticated} />}>
        <Route path="/inventory" element={<Inventory />} />
      </Route>
    </Route>
  </Routes>
</Suspense>
```

---

## 7Ô∏è‚É£ What Happens Behind the Scenes?

When app loads:

```
‚úì App shell loads
‚úì Navbar loads
‚úì Footer loads
‚úó Pages NOT loaded yet
```

When user clicks `/catalog`:

```
‚Üí Download Catalog chunk
‚Üí Render Catalog
```

---

## 8Ô∏è‚É£ Where to Place `Suspense` (Best Practice)

### Option 1: One global fallback (simple)

```jsx
<Suspense fallback={<Loader />}>
  <Routes />
</Suspense>
```

### Option 2: Per-route fallback (advanced)

```jsx
<Route
  path="/catalog"
  element={
    <Suspense fallback={<PageLoader />}>
      <Catalog />
    </Suspense>
  }
/>
```

We‚Äôll stick to **Option 1** for now.

---

## 9Ô∏è‚É£ Do NOT Lazy Load These

‚ùå Layouts (Navbar, Footer)
‚ùå Auth providers
‚ùå App root

These must load immediately.

---

## üîë Key Rules (Memorize)

* Lazy load **pages**, not layout
* `lazy()` always needs `Suspense`
* Lazy loading is **async import**
* Improves performance automatically

---

## 10Ô∏è‚É£ How This Fits Your Microservices Frontend

Your Play frontend:

* Catalog ‚Üí Catalog microservice
* Inventory ‚Üí Inventory microservice

Lazy loading ensures:

* Inventory code loads **only when needed**
* Protected + lazy = best combo
